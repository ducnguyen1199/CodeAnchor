/**
 * Watch Command
 *
 * Watches for file changes and automatically syncs documentation
 * Uses chokidar for efficient file system monitoring
 */

import chalk from 'chalk';
import chokidar from 'chokidar';
import { configLoader } from '../../core/config-loader.js';
import { syncCommand } from './sync.js';

export interface WatchOptions {
  ai?: boolean;
}

export async function watchCommand(options: WatchOptions = {}): Promise<void> {
  try {
    // Load config
    const config = await configLoader.loadOrThrow();

    if (!config.detection.enabled) {
      console.log(chalk.yellow('âš ï¸  Component detection is disabled in config'));
      return;
    }

    console.log(chalk.cyan('\nðŸ‘€ Watching for changes...\n'));

    // Display watch patterns
    console.log(chalk.gray('Patterns:'));
    config.detection.watchPatterns.forEach(pattern => {
      console.log(chalk.gray(`  â€¢ ${pattern}`));
    });

    const ignore = config.detection.ignore || ['node_modules/**', 'dist/**', '.anchor/**', '**/README.md'];

    console.log(chalk.gray('\nIgnoring:'));
    ignore.forEach(pattern => {
      console.log(chalk.gray(`  â€¢ ${pattern}`));
    });

    console.log();

    // Track file changes with debouncing
    let isProcessing = false;
    const changedFiles = new Set<string>();
    let debounceTimer: NodeJS.Timeout | null = null;

    const processChanges = async () => {
      if (isProcessing || changedFiles.size === 0) return;

      isProcessing = true;
      const files = Array.from(changedFiles);
      changedFiles.clear();

      console.log(chalk.cyan(`\nðŸ“ Processing ${files.length} changed file(s)...`));
      files.forEach(file => {
        console.log(chalk.gray(`  â€¢ ${file}`));
      });

      try {
        await syncCommand({ fast: true, ai: options.ai });
      } catch (error) {
        console.error(chalk.red('âœ— Sync failed:'), error);
      }

      isProcessing = false;

      // Check if more files changed while processing
      if (changedFiles.size > 0) {
        processChanges();
      } else {
        console.log(chalk.gray('\nðŸ‘€ Watching for changes...\n'));
      }
    };

    // Setup file watcher
    const watcher = chokidar.watch(config.detection.watchPatterns, {
      ignored: ignore,
      persistent: true,
      ignoreInitial: true,
      awaitWriteFinish: {
        stabilityThreshold: 300,
        pollInterval: 100
      }
    });

    // Handle file changes
    watcher
      .on('change', (path) => {
        changedFiles.add(path);

        // Debounce: wait 500ms after last change
        if (debounceTimer) {
          clearTimeout(debounceTimer);
        }

        debounceTimer = setTimeout(() => {
          processChanges();
        }, 500);
      })
      .on('add', (path) => {
        console.log(chalk.green(`\nâœ“ New file detected: ${path}`));
        changedFiles.add(path);

        if (debounceTimer) {
          clearTimeout(debounceTimer);
        }

        debounceTimer = setTimeout(() => {
          processChanges();
        }, 500);
      })
      .on('unlink', (path) => {
        console.log(chalk.yellow(`\nâš ï¸  File deleted: ${path}`));
        // Note: Could cleanup README.md here in future
      })
      .on('error', (error) => {
        console.error(chalk.red('\nâœ— Watcher error:'), error);
      });

    // Handle graceful shutdown
    const cleanup = () => {
      console.log(chalk.yellow('\n\nâ¹  Stopping watcher...'));
      watcher.close();
      process.exit(0);
    };

    process.on('SIGINT', cleanup);
    process.on('SIGTERM', cleanup);

    // Initial sync if configured
    if (config.detection.autoGenerateDocs) {
      console.log(chalk.gray('Running initial sync...\n'));
      await syncCommand({ fast: true, ai: options.ai });
      console.log(chalk.gray('\nðŸ‘€ Watching for changes...\n'));
    } else {
      console.log(chalk.green('âœ“ Watcher started'));
    }

    // Keep process alive
    await new Promise(() => {});

  } catch (error) {
    console.error(chalk.red('\nâœ— Watch failed:'), error);
    process.exit(1);
  }
}
